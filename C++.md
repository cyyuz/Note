# 1. C++语言基础

c++内存对齐有哪几种方式

# 2. 面向对象编程

## 空类

任何类类型对象的大小至少为 **1 字节**，即使类为空（无任何非静态成员变量）。若空类大小为 0，多个对象可能共享同一内存地址（地址唯一性）。  

空类（无显式声明成员函数时）会由编译器自动生成以下成员函数：默认构造函数、拷贝构造、拷贝赋值、析构函数、移动构造函数、移动赋值运算符。

## 拷贝构造和拷贝复制

编译器默认的拷贝构造、拷贝赋值是浅拷贝，只是拷贝对象里值。

## 移动构造和移动赋值

## C++重载

## 单例模式

把构造函数放在private,只允许外界创建一个例子

```cpp
class A
{
public:
    static A& getInstance();
    setup() {...}
private:
    A();
    A(const A& rhs);
    ...
};

A& A::getInstance()
{
    static A a;
    return a;
}

A::getInstance().setup();   //通过调用这个函数创建对象
```

## 菱形继承

怎么解决的？

多继承存在什么问题？如何消除多继承中的二义性？

# 3. C++11

## 智能指针

### 显示内存管理的问题

- 野指针：一些内存单元已释放，指向它的指针却还在被使用。这些内存可能被运行时系统重新分配给程序使用，从而导致无法预测的错误。
- 重复释放：释放已经被释放过的内存，或者释放已经被重新分配过的内存，就会导致重复释放错误。
- 内存泄漏：不再需要使用的内存如果没有被释放就会导致内存泄漏。如果程序不断地重复进行这类操作，将会导致内存占用剧增。

### 什么是智能指针

以对象的方式管理堆分配的内存，并在适当的时间（指针对象析构、调用reset成员），释放所获得的堆内存。避免堆内存忘记释放而造成的问题。

### auto_ptr

在C++98中，智能指针通过一个模板类型 “auto_ptr” 来实现。

auto_ptr有一些缺点（拷贝时返回一个左值，不能调用 delete[] 等），所以在 C++11标准中被废弃了。

### unique_ptr

unique_ptr 不能与其他 unique_ptr 类型的指针对象共享所指对象的内存，仅能通过move函数转移所有权。

从实现上看，unique_ptr 是一个删除了拷贝构造函数、保留了移动构造函数的指针封装类型。

### shared_ptr

shared_ptr 允许多个该智能指针共享地 “拥有” 同一堆分配对象的内存。

在实现上采用引用计数，当一个shared_ptr 指针失效只会导致引用计数降低，其他的 shared_ptr 对对象内存的引用并不会受到影响。只有在引用计数归零的时候，share_ptr 才会真正释放所占有的堆内存的空间。

### weak_ptr

weak_ptr 可以指向 shared_ptr 指针指向的对象内存，却并不拥有该内存。

使用 weak_ptr 成员 lock，可返回其指向内存的一个 shared_ptr 对象，在所指对象内存已经无效时，返回指针空值 nullptr。可以验证 shared_ptr 指针的有效性。

只有 shared_ptr 参与了引用计数，而 weak_ptr 没有影响其指向的内存的引用计数。

> shared ptr及weak ptr 可用在用户需要引用计数的地方。

# 4. STL

# 5. C++网络编程

## 字节序

字节序：顾名思义字节的顺序，就是大于一个字节欸行的数据在内存中的存放顺序（一个字节的数据当然就无需谈顺序的问题了），注意：网络字节序都是大端。

字节序分为大端字节序和小端字节序。大端字节序指一个整数的最高位字节（24-31bit）存储在内存的低地址处，低位字节（0-7bit）存储在内存的高地址处；小端字节序则是指整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地址处。

## 什么是IO多路复用
2. 说说IO多路复用优缺点？
3. 说说select机制的缺点
4. epoll中et和lt的区别与实现原理  水平出发边缘触发
5. 说一下epoll的好处
6. epoll需要在用户态和内核态拷贝数据么？
7. 网络编程的一般步骤
8. socket编程，如果client断电了，服务器如何快速知道？
9. socket在什么情况下可读?
10. connect方法会阻塞，请问有什么方法可以避免其长时间阻塞？
11. 网络编程中设计并发服务器，使用多进程 与 多线程 ，请问有什么区别？
12. TCP通讯中，select到读事件，但是读到的数据量是0，为什么，如何解决?

# 6. C++内存管理

# 7. C++并发编程
